# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '.\TCPServer_UI_V11_only_acceleration.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import socket
import threading

from PyQt5.QtCore import QTimer

from openpyxl import Workbook
import time

import math
from io import TextIOWrapper

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QThread, pyqtSignal
from PyQt5.QtWidgets import (QApplication, QMessageBox)
from mplwidget import MplWidget

import pandas as pd
import serial
from scipy.signal import butter, filtfilt

import numpy as np
from myUDP_GUI_2 import Ui_MainWindow

HOST = '0.0.0.0'
PORT = 8000
client_ip = '0.0.0.0'

time_reset = 500

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect(("8.8.8.8", 80))
HOST = s.getsockname()[0]
s.close()

t_list = []
t_rms_list = []
t_rms_buf = 0
save_rms_num = 0

accelerometer_x = []        #加速度計
accelerometer_y = []
accelerometer_z = []

accelerometer_xrms = []     #加速度計_rms
accelerometer_yrms = []
accelerometer_zrms = []

accelerometer_xrms_buf = [] #加速度計_rms 暫存
accelerometer_yrms_buf = []
accelerometer_zrms_buf = []


excel_state = False
accelerometer_excel = []
accelerometer_rms_excel = []

t=0
t_rms  = 0
origin = 0
lock = 0
reset_num = 0
ex_row = 1

msg_error = False
LC = 0
HC = 0

sampleRate_rate = 6200
rms_list_sec = 300


class WorkerThread_UDP(QThread): 
    trigger = pyqtSignal(list)
    freq_trigger = pyqtSignal(int)
    def __init__(self):
        super().__init__()
        self.host = HOST
        self.port = PORT
        self.frequency = 0
        self.frequency_timer = QtCore.QTimer()# Frequency Timer
        self.frequency_timer.timeout.connect(self.update_frequency)
        self.frequency_timer.start(1000)
    def run(self):
        self.doConnect()
        while True:
            try:
                #client, addr = self.server.accept()
                # self.recv_msg(client, addr)
                #threading.Thread(target=self.send_msg, args=(client, addr)).start()
                message, address = self.server.recvfrom(2000)
                data = message.decode("utf-8")
                data_list = data.split('#')
                data_len = len(data_list)
                if data_len > 0:
                    self.frequency += data_len
                    self.trigger.emit(data_list)
                # if len(data)>=20:
                #     self.trigger.emit(data)
                    #print('封包長度: ',len(data))
                    #print('Client data is:', data)
                    #serverMessage = 'Data has been received!'
                    #conn.sendall(serverMessage.encode())
                else:
                    #print('ERROR data is:', data)
                    print('Client data is ERROR')
                # threading.Thread(target=self.recv_msg, args=(message, address)).start()
            except socket.error:
                print('socket connect error, doing connect host/port:{}/{}'.format(self.host, self.port))
                self.doConnect()
            except Exception as e:
                print('other error occur:{}'.format(e))
    
    def doConnect(self):
        try:
            self.server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)            # 防止socket server重启后端口被占用（socket.error: [Errno 98] Address already in use）
            # self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server.bind((self.host, self.port))
            # self.server.listen(5)
            print('-----------------------------------------------------------')
            print("esWsServer host:{}/port:{} started listen...".format(self.host, self.port))
            print('-----------------------------------------------------------')
        except Exception as e:
            print('start ws server error:{}'.format(str(e)))
    def update_frequency(self):
        self.freq_trigger.emit(self.frequency)
        self.frequency = 0
    def recv_msg(self, message, addr):
        global client_ip
        try:
            # self.send_msg(client, addr)
            # print('Accept new connection from {0}'.format(addr))
            client_ip = addr[0]
            # print('Client IP: ',client_ip)
            # data = str(client.recv(2048), encoding='utf-8', errors='ignore')
            data = message.decode("utf-8")
            print('recv msg:', data)
                #serverMessage = 'Data is error!'
                #conn.sendall(serverMessage.encode())
            if len(data)>=20:
                self.trigger.emit(data)
                #print('封包長度: ',len(data))
                #print('Client data is:', data)
                #serverMessage = 'Data has been received!'
                #conn.sendall(serverMessage.encode())
            else:
                #print('ERROR data is:', data)
                print('Client data is ERROR')

        except Exception as e:
            print('recv_msg:{}'.format(e))

class WorkerThread(QThread): 
    trigger = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.host = HOST
        self.port = PORT
        
    
    def run(self):
        self.doConnect()
        while True:
            try:
                client, addr = self.server.accept()
                # self.recv_msg(client, addr)
                #threading.Thread(target=self.send_msg, args=(client, addr)).start()
                threading.Thread(target=self.recv_msg, args=(client, addr)).start()
            except socket.error:
                print('socket connect error, doing connect host/port:{}/{}'.format(self.host, self.port))
                self.doConnect()
            except Exception as e:
                print('other error occur:{}'.format(e))
    
    def doConnect(self):
        try:
            self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            # 防止socket server重启后端口被占用（socket.error: [Errno 98] Address already in use）
            self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server.bind((self.host, self.port))
            self.server.listen(5)
            print('-----------------------------------------------------------')
            print("esWsServer host:{}/port:{} started listen...".format(self.host, self.port))
            print('-----------------------------------------------------------')
        except Exception as e:
            print('start ws server error:{}'.format(str(e)))
    
    def recv_msg(self, client, addr):
        global client_ip
        try:
            # self.send_msg(client, addr)
            print('Accept new connection from {0}'.format(addr))
            client_ip = addr[0]
            print('Client IP: ',client_ip)
            while 1:
                data = str(client.recv(4096), encoding='utf-8', errors='ignore')
                # print('recv msg')
                if data == "IMU ERR\n":
                    print('Client data is:', data)
                    #serverMessage = 'Data is error!'
                    #conn.sendall(serverMessage.encode())
                elif len(data)>=20:
                    self.trigger.emit(data)
                    #print('封包長度: ',len(data))
                    #print('Client data is:', data)
                    #serverMessage = 'Data has been received!'
                    #conn.sendall(serverMessage.encode())
                else:
                    #print('ERROR data is:', data)
                    print('Client data is ERROR')

        except Exception as e:
            print('recv_msg:{}'.format(e))

class SaveThread(QThread):
    set_trigger = pyqtSignal(int)
    data_trigger = pyqtSignal(list)
    close_trigger = pyqtSignal(bool)
    def __init__(self, accelerometer_excel, accelerometer_rms_excel, acc_file, rms_file):
        super().__init__()
        self.accelerometer_excel = accelerometer_excel
        self.acc_file = acc_file
        self.rms_file = rms_file
        # self.bar1 = bar1
        # self.progress_bar = progress_bar
        self.accelerometer_rms_excel = accelerometer_rms_excel

    def run(self):
        initial_value = 0
        # self.bar1.setValue(0)    
        # self.bar1.setRange(0, len(self.accelerometer_excel))
        # self.progress_bar.show()
        #print(self.accelerometer_excel)
        accelerometer_excel_len = len(self.accelerometer_excel)
        self.set_trigger.emit(accelerometer_excel_len)
        while len(self.accelerometer_excel)>0:
                           
            self.acc_file.write(f"{round(float(self.accelerometer_excel[0][0]),4)},{round(float(self.accelerometer_excel[0][1]),4)},{round(float(self.accelerometer_excel[0][2]),4)}\n")
            self.accelerometer_excel.pop(0)
            initial_value += 1
            self.data_trigger.emit([initial_value,accelerometer_excel_len])
            # self.bar1.setValue(initial_value)
        
        self.acc_file.close()

        initial_value = 0
        # self.bar1.setValue(0)  
        # self.bar1.setRange(0, len(self.accelerometer_rms_excel))
        
        accelerometer_rms_excel_len = len(self.accelerometer_rms_excel)
        self.set_trigger.emit(accelerometer_rms_excel_len)
        while len(self.accelerometer_rms_excel)>0:
            self.rms_file.write(f"{round(float(self.accelerometer_rms_excel[0][0]),4)},{round(float(self.accelerometer_rms_excel[0][1]),4)},{round(float(self.accelerometer_rms_excel[0][2]),4)},{self.accelerometer_rms_excel[0][3]}\n")
            self.accelerometer_rms_excel.pop(0)
            initial_value += 1
            self.data_trigger.emit([initial_value,accelerometer_excel_len])
            # self.bar1.setValue(initial_value)
        # self.progress_bar.close()
        self.rms_file.close()
        self.close_trigger.emit(True)

    

    

class WorkerThread_COM(QThread): 
    trigger = pyqtSignal(list)
    batt_trigger = pyqtSignal(str)
    freq_trigger = pyqtSignal(int)
    def __init__(self):
        super().__init__()
        self.com = "COM4"
        self.baud = 2000000
        self.frequency = 0
        self.frequency_timer = QtCore.QTimer()# Frequency Timer
        self.frequency_timer.timeout.connect(self.update_frequency)
        self.frequency_timer.start(1000)
    def run(self):
        self.doConnect()
        pre_data = ""
        pre_batt = ""
        batt = ""
        while True:
            try:
                # data = self.ser.readline().decode()
                data = self.ser.read(self.ser.in_waiting).decode()
                data_list = []
                
                if len(data) > 0:
                    batt_begin_tag = data.find("(")
                    batt_end_tag = data.find(")")
                    #print(data)
                    if batt_begin_tag != -1 and batt_end_tag != -1:
                        batt = data[batt_begin_tag+1:batt_end_tag]
                        data = data[:batt_begin_tag] + data[batt_end_tag+1:]
                        #print(batt)
                        self.batt_trigger.emit(batt)
                    elif batt_begin_tag != -1 and batt_end_tag == -1:
                        pre_batt = data[batt_begin_tag+1:]
                        data = data[:batt_begin_tag]
                    elif batt_begin_tag == -1 and batt_end_tag != -1:
                        batt = pre_batt + data[:batt_end_tag]
                        data = data[batt_end_tag+1:]
                        #print(batt)
                        self.batt_trigger.emit(batt)
                        pre_batt = ""
                    first_tag = data.find("#")
                    last_tag = data.rfind("#")
                    if first_tag == -1:
                        pre_data += data
                    else:
                        if first_tag == 0:
                            data_list.append(pre_data)
                        else:
                            data_list.append(pre_data + data[:first_tag])
                        if last_tag == len(data)-1:
                            pre_data = ""
                        else:
                            pre_data = data[last_tag+1:]
                        
                        if first_tag != last_tag:
                            data_list += data[first_tag+1:last_tag].split("#")
                    data_len = len(data_list)
                    if data_len > 0:
                        self.frequency += data_len
                        self.trigger.emit(data_list)
            except Exception as e:
                print('other error occur:{}'.format(e))
    
    def doConnect(self):
        try:
            self.ser = serial.Serial(self.com, self.baud,timeout=2)
            print('-----------------------------------------------------------')
            print("COM :{}/baud rate :{}".format(self.com, self.baud))
            print('-----------------------------------------------------------')
        except Exception as e:
            print('connect com error:{}'.format(str(e)))
    def update_frequency(self):
        self.freq_trigger.emit(self.frequency)
        self.frequency = 0



class MainWindow_controller(QtWidgets.QMainWindow):
        def __init__(self):
            super().__init__() # in python3, super(Class, self).xxx = super().xxx
            self.ui = Ui_MainWindow()
            # self.MainWindow = QtWidgets.QMainWindow()
            self.ui.setupUi(self)
            self.drawtimer = QtCore.QTimer()#Timer
            
            
            self.listx_max = 0.5
            self.listy_max = 0.5
            self.listz_max = 0.5
            self.listx_min = -0.5
            self.listy_min = -0.5
            self.listz_min = -0.5

            self.acc_Xmax = '0.5'
            self.acc_Ymax = '0.5'
            self.acc_Zmax = '0.5'
            self.acc_Xmin = '-0.5'
            self.acc_Ymin = '-0.5'
            self.acc_Zmin = '-0.5'

            self.rms_Xmax = '0.5'
            self.rms_Ymax = '0.5'
            self.rms_Zmax = '0.5'
            self.rms_Xmin = '-0.5'
            self.rms_Ymin = '-0.5'
            self.rms_Zmin = '-0.5'   

            self.mode = ''     

            self.mean_x = 0.0
            self.mean_y = 0.0
            self.mean_z = 0.0
            self.rms_x = 0.0
            self.rms_y = 0.0
            self.rms_z = 0.0

            self.acc_file = ''
            self.rms_file = ''
            self.accelerometer_txt = []
            self.accelerometer_rms_txt = []
            
            self.frequency_list = []

            self.acc_mode = 64

            self.progress_bar = QtWidgets.QWidget()
            self.progress_bar.setWindowTitle('存取中...')
            self.progress_bar.resize(250, 80)

            style = '''
                QProgressBar {
                    border: 2px solid #000;
                    border-radius: 5px;
                    text-align:center;
                    height: 20px;
                    width:200px;
                }
                QProgressBar::chunk {
                    background: #09c;
                    width:1px;
                }
            '''

            self.bar1 = QtWidgets.QProgressBar(self.progress_bar)
            self.bar1.move(20,20)
            self.bar1.setRange(0, 100)
            self.bar1.setValue(0)
            self.bar1.setStyleSheet(style)
            self.bar1.setFormat('%v/%m') 

            self.setup_control()

        def setup_control(self):
            #設定
            #------------------------元件初始化(勿動)--------------------------#
            self.ui.LineEdit_client.setReadOnly(True)
            self.ui.LineEdit_hostIP.setReadOnly(True)
            self.ui.line_accX.setReadOnly(True)
            self.ui.line_accY.setReadOnly(True)
            self.ui.line_accZ.setReadOnly(True)
            self.ui.btn_save.setEnabled(False)
            self.ui.lineEdit_lowcut.setText('250')
            self.ui.lineEdit_highcut.setText('499')

            self.ui.lineEdit_Xmax.setText("0.5")
            self.ui.lineEdit_Xmin.setText("-0.5")
            self.ui.lineEdit_Ymax.setText("0.5")
            self.ui.lineEdit_Ymin.setText("-0.5")
            self.ui.lineEdit_Zmax.setText("0.5")
            self.ui.lineEdit_Zmin.setText("-0.5")
            #------------------------功能初始化-------------------------------#
            self.ui.ckb_acc.setChecked(False)
            self.ui.ckb_rms.setChecked(False)
            self.ui.ckb_X.setChecked(False)
            self.ui.ckb_Y.setChecked(False)
            self.ui.ckb_Z.setChecked(False)
            #--------------------------主功能---------------------------------#
            self.ui.btn_stop.clicked.connect(self.btn_lock)#圖表暫停功能
            self.ui.ckb_acc.clicked.connect(self.click_acc)
            self.ui.ckb_acc_out.clicked.connect(self.click_acc_out)
            self.ui.ckb_rms.clicked.connect(self.click_rms)
            self.ui.btn_displaySetting_confirm.clicked.connect(self.click_confirm_btn)

            self.ui.ckb_X.clicked.connect(self.click_X)
            self.ui.ckb_Y.clicked.connect(self.click_Y)
            self.ui.ckb_Z.clicked.connect(self.click_Z)
            self.ui.ComboBox_accMode.currentIndexChanged.connect(self.change_accMode)
            self.ui.btn_record.clicked.connect(self.click_record_txt)
            
            self.ui.btn_save.clicked.connect(self.click_save_txt_thread)
            
            
            #線程
            # self.work = WorkerThread()#呼叫TCP線程
            self.work = WorkerThread_COM()
            self.ui.btn_IPsearch.clicked.connect(self.startThread)
            
            #Timer(更新曲線圖)
            # self.drawtimer = QtCore.QTimer()#Timer
            self.drawtimer.timeout.connect(self.update_graph)
            self.drawtimer.start(5)
            

        def startThread(self):
            self.ui.btn_IPsearch.setEnabled(False)
            self.ui.LineEdit_hostIP.setText(HOST)
            self.work.start()
            self.work.trigger.connect(self.update_data)
            self.work.freq_trigger.connect(self.frequency_count)
            self.work.batt_trigger.connect(self.batt_update)

        def update_data(self, list_msg):
            global client_ip
            global t
            global t_rms
            global t_rms_list
            global t_rms_buf
            global origin
            global t_list
            global accelerometer_x
            global accelerometer_y
            global accelerometer_z
            global accelerometer_xrms
            global accelerometer_yrms
            global accelerometer_zrms
            global accelerometer_xrms_buf
            global accelerometer_yrms_buf
            global accelerometer_zrms_buf
            global msg_error
            global save_rms_num

            Sinv1 = 0.997505962789974
            Sinv2 = -0.00301557240986264
            Sinv3 = 0.00637532022597012
            Sinv4 = 1.00364841127970
            Sinv5 = -0.00306140687472731
            Sinv6 = 0.991378157418732
            bx = 0.0440255579322385
            by = 0.0395858900548583
            bz = -0.0394661482642032
            
            #print(client_ip)
            # self.ui.LineEdit_client.setText(client_ip)
            # list_msg = msg.split('#')
            # print(len(list_msg))
            if(len(list_msg)>0):
                #start_time = time.time()
                while len(list_msg)>0:
                    list_data = list_msg[0].split(',')
                    list_msg.pop(0)
                    msg_error=False
                    try:
                        '''
                        float(list_data[0])
                        float(list_data[1])
                        float(list_data[2])
                        '''
                        int(list_data[0])
                        int(list_data[1])
                        int(list_data[2])
                    except:
                        msg_error=True
                    if(msg_error==False):
                        
                        #if "." in list_data[0]:        #or float(list_data[0])==16.0
                        Ax = round(float(list_data[0])/1000,3)
                        Ay = round(float(list_data[1])/1000,3)
                        Az = round(float(list_data[2])/1000,3)

                        Ax = max(min(self.acc_mode,Ax),-self.acc_mode) #最大最小值擷取
                        Ay = max(min(self.acc_mode,Ay),-self.acc_mode) #最大最小值擷取
                        Az = max(min(self.acc_mode,Az),-self.acc_mode) #最大最小值擷取

                        ax = round(Sinv1*(Ax - bx) + Sinv2*(Ay - by) + Sinv3*(Az - bz),3)
                        ay = round(Sinv2*(Ax - bx) + Sinv4*(Ay - by) + Sinv5*(Az - bz),3)
                        az = round(Sinv3*(Ax - bx) + Sinv5*(Ay - by) + Sinv6*(Az - bz),3)
                    
                        if(excel_state == True):                                #判斷是否需要紀錄  
                            # accelerometer_data = []
                            # accelerometer_data.append(ax)
                            # accelerometer_data.append(ay)
                            # accelerometer_data.append(az)                             
                            accelerometer_excel.append([ax,ay,az])        #開始記錄
                            #---------------------RMS---------------------#
                            if len(accelerometer_excel) - (save_rms_num) >= sampleRate_rate:
                                accelerometer_rms_data = []
                                #print(f"start: {save_rms_num + 1} end: {len(accelerometer_excel)}")
                                mean_x = 0
                                mean_y = 0
                                mean_z = 0
                                for x,y,z in accelerometer_excel[save_rms_num:]:
                                    mean_x += x
                                    mean_y += y
                                    mean_z += z
                                mean_x /= len(accelerometer_excel[save_rms_num:])
                                mean_y /= len(accelerometer_excel[save_rms_num:])
                                mean_z /= len(accelerometer_excel[save_rms_num:])

                                accelerometer_rms_data.append(math.sqrt(sum([(x[0]-mean_x) ** 2 for x in accelerometer_excel[save_rms_num:]]) / len(accelerometer_excel[save_rms_num:])))
                                accelerometer_rms_data.append(math.sqrt(sum([(y[1]-mean_y) ** 2 for y in accelerometer_excel[save_rms_num:]]) / len(accelerometer_excel[save_rms_num:])))
                                accelerometer_rms_data.append(math.sqrt(sum([(z[2]-mean_z) ** 2 for z in accelerometer_excel[save_rms_num:]]) / len(accelerometer_excel[save_rms_num:])))
                                accelerometer_rms_data.append(f"start: {save_rms_num + 1} end: {len(accelerometer_excel)} end_num: {round(accelerometer_excel[-1][0],3)},{round(accelerometer_excel[-1][1],3)},{round(accelerometer_excel[-1][2],3)}")
                                #print(accelerometer_rms_data)
                                accelerometer_rms_excel.append(accelerometer_rms_data)
                                print((len(accelerometer_excel[save_rms_num:])))
                                save_rms_num = len(accelerometer_excel)
                            # if t_rms_list[-1] - t_rms_buf > 0:
                            #     accelerometer_rms_data = []
                            #     accelerometer_rms_data.append(accelerometer_xrms[-1])
                            #     accelerometer_rms_data.append(accelerometer_yrms[-1])
                            #     accelerometer_rms_data.append(accelerometer_zrms[-1])
                            #     accelerometer_rms_data.append(f"{len(accelerometer_excel)}_end")
                            #     #print(accelerometer_rms_data)
                            #     accelerometer_rms_excel.append(accelerometer_rms_data)
                            

                            # t_rms_buf = t_rms_list[-1]
                            #print(accelerometer_excel)
                        '''
                        self.line_accX.setText(str(round(float(list_data[0]),2)))
                        accelerometer_x.append(float(list_data.pop(0))) #拿取資料後刪除該資料
                        self.line_accY.setText(str(round(float(list_data[0]),2)))
                        accelerometer_y.append(float(list_data.pop(0)))
                        self.line_accZ.setText(str(round(float(list_data[0]),2)))
                        accelerometer_z.append(float(list_data.pop(0)))
                        '''
                        
                        # self.ui.line_accX.setText(str(ax))
                        accelerometer_x.append(ax) #拿取資料後刪除該資料
                        # self.ui.line_accY.setText(str(ay))
                        accelerometer_y.append(ay)
                        # self.ui.line_accZ.setText(str(az))
                        accelerometer_z.append(az)

                        #-------------------------RMS-------------------------#
                        accelerometer_xrms_buf.append(ax)
                        accelerometer_yrms_buf.append(ay)
                        accelerometer_zrms_buf.append(az)

                        if len(accelerometer_xrms_buf) >= sampleRate_rate:
                            #print(x for x in accelerometer_xrms_buf)

                            mean_x = sum([x for x in accelerometer_xrms_buf]) / len(accelerometer_xrms_buf)
                            mean_y = sum([y for y in accelerometer_yrms_buf]) / len(accelerometer_yrms_buf)
                            mean_z = sum([z for z in accelerometer_zrms_buf]) / len(accelerometer_zrms_buf)

                            accelerometer_xrms.append(math.sqrt(sum([(x - mean_x) ** 2 for x in accelerometer_xrms_buf]) / len(accelerometer_xrms_buf)))
                            accelerometer_yrms.append(math.sqrt(sum([(y - mean_y) ** 2 for y in accelerometer_yrms_buf]) / len(accelerometer_yrms_buf)))
                            accelerometer_zrms.append(math.sqrt(sum([(z - mean_z) ** 2 for z in accelerometer_zrms_buf]) / len(accelerometer_zrms_buf)))
                            t_rms = t_rms + 1
                            t_rms_list.append(t_rms)
                            accelerometer_xrms_buf = []
                            accelerometer_yrms_buf = []
                            accelerometer_zrms_buf = []

                            if len(t_rms_list) > rms_list_sec:
                                accelerometer_xrms.pop(0)
                                accelerometer_yrms.pop(0)
                                accelerometer_zrms.pop(0)
                                t_rms_list.pop(0)
                                # print(accelerometer_xrms)
                                # print(t_rms_list)

                        list_data.pop(0)
                        t = t + 1
                        #t_list.append(t)
                        t_list.append(t/sampleRate_rate)
                        if t > sampleRate_rate:
                            origin = t-sampleRate_rate
                        if t > sampleRate_rate:
                            t_list.pop(0)
                            accelerometer_x.pop(0)
                            accelerometer_y.pop(0)
                            accelerometer_z.pop(0)

                            #-------------------------RMS-------------------------#
                            # accelerometer_xrms_buf.append(accelerometer_x)
                            #accelerometer_yrms_buf.append(accelerometer_y)
                            # accelerometer_zrms_buf.append(accelerometer_z)

                            # if len(accelerometer_x) >= sampleRate_rate:
                            #     accelerometer_xrms.append(math.sqrt(sum([x ** 2 for x in accelerometer_x]) / len(accelerometer_x)))
                            #     # print(math.sqrt(sum([x ** 2 for x in accelerometer_x]) / len(accelerometer_x)))
                            #     t_rms_list.append(len(accelerometer_xrms))
                        
                        
                            #print('acc_len=',len(t_list))
                    else:
                        pass
                        # print(list_data)
                # self.ui.line_accX.setText(str(ax))
                # self.ui.line_accY.setText(str(ay))
                # self.ui.line_accZ.setText(str(az))
                #end_time = time.time()
                #execution_time = end_time - start_time
                #print("程式執行時間：", execution_time, "秒")

        def update_graph(self):
            global origin
            global t_list
            global accelerometer_x
            global accelerometer_y
            global accelerometer_z
            global LC
            global HC
            # listx_max = 0.5
            # listy_max = 0.5
            # listz_max = 0.5
            # listx_min = -0.5
            # listy_min = -0.5
            # listz_min = -0.5

            # 設置濾波器參數
            lowcut = LC  # 低頻截止頻率，單位為Hz
            highcut = HC  # 高頻截止頻率，單位為Hz
            fs = 6400  # 采樣頻率，單位為Hz
            order = 2  # 濾波器階數        

            if lock == 0:
                # if len(accelerometer_x)>0:
                #     self.listx_max = max(accelerometer_x) + 0.2
                #     self.listy_max = max(accelerometer_y) + 0.2
                #     self.listz_max = max(accelerometer_z) + 0.2
                #     self.listx_min = min(accelerometer_x) - 0.2
                #     self.listy_min = min(accelerometer_y) - 0.2
                #     self.listz_min = min(accelerometer_z) - 0.2

                    #--------------------RMS--------------------#
                if len(accelerometer_xrms) > 0:
                    listxrms_max = max(accelerometer_xrms) + 0.005
                    listyrms_max = max(accelerometer_yrms) + 0.005
                    listzrms_max = max(accelerometer_zrms) + 0.005
                    listxrms_min = min(accelerometer_xrms) - 0.005
                    listyrms_min = min(accelerometer_yrms) - 0.005
                    listzrms_min = min(accelerometer_zrms) - 0.005

                if self.ui.ckb_acc.isChecked():
                    # self.current_mode() 
                    self.ui.MplWidget.canvas.figure.clf()
                    # self.MplWidget.canvas.axes0 = self.MplWidget.canvas.figure.add_subplot(311)
                    # self.MplWidget.canvas.axes1 = self.MplWidget.canvas.figure.add_subplot(312)
                    # self.MplWidget.canvas.axes2 = self.MplWidget.canvas.figure.add_subplot(313)

                    #-----------------------------RMS-----------------------------#
                    self.ui.MplWidget.canvas.axes0 = self.ui.MplWidget.canvas.figure.add_subplot(311)#3行1列第1個
                    self.ui.MplWidget.canvas.axes1 = self.ui.MplWidget.canvas.figure.add_subplot(312)#3行1列第2個
                    self.ui.MplWidget.canvas.axes2 = self.ui.MplWidget.canvas.figure.add_subplot(313)#3行1列第3個
                    

                    self.ui.MplWidget.canvas.axes0.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes0.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes0.set_xlim([origin/sampleRate_rate, t/sampleRate_rate]) #設定x軸的顯示範圍
                    #sel.uif.MplWidget.canvas.axes0.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes0.set_ylim([self.listx_min, self.listx_max])
                    self.ui.MplWidget.canvas.axes0.plot(t_list, accelerometer_x, color='red')

                    self.ui.MplWidget.canvas.axes1.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes1.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes1.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes1.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes1.set_ylim([self.listy_min, self.listy_max])
                    self.ui.MplWidget.canvas.axes1.plot(t_list, accelerometer_y, color='green') 

                    self.ui.MplWidget.canvas.axes2.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes2.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes2.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes2.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes2.set_ylim([self.listz_min, self.listz_max])
                    self.ui.MplWidget.canvas.axes2.plot(t_list, accelerometer_z, color='blue')

                    self.ui.MplWidget.canvas.axes0.set_title('Accelerometer (X)')
                    self.ui.MplWidget.canvas.axes1.set_title('Accelerometer (Y)') 
                    self.ui.MplWidget.canvas.axes2.set_title('Accelerometer (Z)')

                    self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                    self.ui.MplWidget.canvas.draw()

                elif self.ui.ckb_acc_out.isChecked():
                    #四分位距法去除離群值
                    out_pd = pd.Index(accelerometer_x)
                    out_x = remove_outliers(out_pd)

                    out_pd = pd.Index(accelerometer_y)
                    out_y = remove_outliers(out_pd)

                    out_pd = pd.Index(accelerometer_z)
                    out_z = remove_outliers(out_pd)

                    '''
                    # 計算濾波器係數
                    nyquist_freq = 0.5 * fs
                    low = lowcut / nyquist_freq
                    high = highcut / nyquist_freq
                    b, a = butter(order, [low, high], btype="bandstop")
                    '''
                    
                    # 設計低通濾波器
                    cutoff = highcut  # 截止頻率
                    nyq = 0.5 * fs  # Nyquist頻率
                    normal_cutoff = cutoff / nyq
                    b, a = butter(4, normal_cutoff, btype='low', analog=False)

                    df_x = filtfilt(b, a, out_x)
                    df_y = filtfilt(b, a, out_y)
                    df_z = filtfilt(b, a, out_z)

                    
                    
                    self.ui.MplWidget.canvas.figure.clf()
                    # self.MplWidget.canvas.axes0 = self.MplWidget.canvas.figure.add_subplot(311)
                    # self.MplWidget.canvas.axes1 = self.MplWidget.canvas.figure.add_subplot(312)
                    # self.MplWidget.canvas.axes2 = self.MplWidget.canvas.figure.add_subplot(313)

                    # #-----------------------------RMS-----------------------------#
                    # self.MplWidget.canvas.axes0 = self.MplWidget.canvas.figure.add_subplot(311)
                    # self.MplWidget.canvas.axes0_rms = self.MplWidget.canvas.figure.add_subplot(312)
                    # self.MplWidget.canvas.axes1 = self.MplWidget.canvas.figure.add_subplot(313)
                    # self.MplWidget.canvas.axes2 = self.MplWidget.canvas.figure.add_subplot(314)

                    self.ui.MplWidget.canvas.axes0.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes0.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes0.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes0.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes0.set_ylim([self.listx_min, self.listx_max])
                    self.ui.MplWidget.canvas.axes0.plot(t_list, df_x, color='red') 

                    self.ui.MplWidget.canvas.axes1.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes1.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes1.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes1.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes1.set_ylim([self.listy_min, self.listy_max])
                    self.ui.MplWidget.canvas.axes1.plot(t_list, df_y, color='green') 

                    self.ui.MplWidget.canvas.axes2.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes2.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes2.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes2.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes2.set_ylim([self.listz_min, self.listz_max])
                    self.ui.MplWidget.canvas.axes2.plot(t_list, df_z, color='blue')

                    self.ui.MplWidget.canvas.axes0.set_title('Accelerometer (X)') 
                    self.ui.MplWidget.canvas.axes1.set_title('Accelerometer (Y)') 
                    self.ui.MplWidget.canvas.axes2.set_title('Accelerometer (Z)') 
                    self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                    self.ui.MplWidget.canvas.draw()

                elif self.ui.ckb_X.isChecked() and self.ui.ckb_Y.isChecked() and self.ui.ckb_Z.isChecked():

                    self.ui.MplWidget.canvas.figure.clf()
                    # self.MplWidget.canvas.axes0 = self.MplWidget.canvas.figure.add_subplot(311)
                    # self.MplWidget.canvas.axes1 = self.MplWidget.canvas.figure.add_subplot(312)
                    # self.MplWidget.canvas.axes2 = self.MplWidget.canvas.figure.add_subplot(313)

                    # #-----------------------------RMS-----------------------------#
                    # self.MplWidget.canvas.axes0 = self.MplWidget.canvas.figure.add_subplot(311)
                    # self.MplWidget.canvas.axes0_rms = self.MplWidget.canvas.figure.add_subplot(312)
                    # self.MplWidget.canvas.axes1 = self.MplWidget.canvas.figure.add_subplot(313)
                    # self.MplWidget.canvas.axes2 = self.MplWidget.canvas.figure.add_subplot(314)

                    self.ui.MplWidget.canvas.axes0.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes0.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes0.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes0.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes0.set_ylim([self.listx_min, self.listx_max])
                    self.ui.MplWidget.canvas.axes0.plot(t_list, accelerometer_x, color='red') 

                    self.ui.MplWidget.canvas.axes1.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes1.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes1.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes1.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes1.set_ylim([self.listy_min, self.listy_max])
                    self.ui.MplWidget.canvas.axes1.plot(t_list, accelerometer_y, color='green') 

                    self.ui.MplWidget.canvas.axes2.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes2.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes2.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes2.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes2.set_ylim([self.listz_min, self.listz_max])
                    self.ui.MplWidget.canvas.axes2.plot(t_list, accelerometer_z, color='blue')

                    self.ui.MplWidget.canvas.axes0.set_title('Accelerometer (X)') 
                    self.ui.MplWidget.canvas.axes1.set_title('Accelerometer (Y)') 
                    self.ui.MplWidget.canvas.axes2.set_title('Accelerometer (Z)') 
                    self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                    self.ui.MplWidget.canvas.draw()
            
                elif self.ui.ckb_X.isChecked() and self.ui.ckb_Y.isChecked():
                    
                    self.ui.MplWidget.canvas.figure.clf()
                    self.ui.MplWidget.canvas.axes0 = self.ui.MplWidget.canvas.figure.add_subplot(211)
                    self.ui.MplWidget.canvas.axes1 = self.ui.MplWidget.canvas.figure.add_subplot(212)

                    self.ui.MplWidget.canvas.axes0.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes0.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes0.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    self.ui.MplWidget.canvas.axes0.set_ylim([self.listx_min, self.listx_max])
                    self.ui.MplWidget.canvas.axes0.plot(t_list, accelerometer_x, color='red') 

                    self.ui.MplWidget.canvas.axes1.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes1.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes1.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    self.ui.MplWidget.canvas.axes1.set_ylim([self.listy_min, self.listy_max])
                    self.ui.MplWidget.canvas.axes1.plot(t_list, accelerometer_y, color='green') 

                    self.ui.MplWidget.canvas.axes0.set_title('Accelerometer (X)') 
                    self.ui.MplWidget.canvas.axes1.set_title('Accelerometer (Y)')  
                    self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                    self.ui.MplWidget.canvas.draw()
                    
                elif self.ui.ckb_X.isChecked() and self.ui.ckb_Z.isChecked():
                  
                    self.ui.MplWidget.canvas.figure.clf()
                    self.ui.MplWidget.canvas.axes0 = self.ui.MplWidget.canvas.figure.add_subplot(211)
                    self.ui.MplWidget.canvas.axes1 = self.ui.MplWidget.canvas.figure.add_subplot(212)

                    self.ui.MplWidget.canvas.axes0.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes0.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes0.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    self.ui.MplWidget.canvas.axes0.set_ylim([self.listx_min, self.listx_max])
                    self.ui.MplWidget.canvas.axes0.plot(t_list, accelerometer_x, color='red') 

                    self.ui.MplWidget.canvas.axes1.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes1.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes1.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    self.ui.MplWidget.canvas.axes1.set_ylim([self.listz_min, self.listz_max])
                    self.ui.MplWidget.canvas.axes1.plot(t_list, accelerometer_z, color='green') 

                    self.ui.MplWidget.canvas.axes0.set_title('Accelerometer (X)') 
                    self.ui.MplWidget.canvas.axes1.set_title('Accelerometer (Z)')  
                    self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                    self.ui.MplWidget.canvas.draw()

                elif self.ui.ckb_Y.isChecked() and self.ui.ckb_Z.isChecked():
                 
                    self.ui.MplWidget.canvas.figure.clf()
                    self.ui.MplWidget.canvas.axes0 = self.ui.MplWidget.canvas.figure.add_subplot(211)
                    self.ui.MplWidget.canvas.axes1 = self.ui.MplWidget.canvas.figure.add_subplot(212)

                    self.ui.MplWidget.canvas.axes0.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes0.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes0.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    self.ui.MplWidget.canvas.axes0.set_ylim([self.listy_min, self.listy_max])
                    self.ui.MplWidget.canvas.axes0.plot(t_list, accelerometer_y, color='red') 

                    self.ui.MplWidget.canvas.axes1.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes1.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes1.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    self.ui.MplWidget.canvas.axes1.set_ylim([self.listz_min, self.listz_max])
                    self.ui.MplWidget.canvas.axes1.plot(t_list, accelerometer_z, color='green') 

                    self.ui.MplWidget.canvas.axes0.set_title('Accelerometer (Y)') 
                    self.ui.MplWidget.canvas.axes1.set_title('Accelerometer (Z)')  
                    self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                    self.ui.MplWidget.canvas.draw()
                    
                elif self.ui.ckb_X.isChecked() and not(self.ui.ckb_rms.isChecked()):
                    
                    #四分位距法去除離群值
                    out_pd = pd.Index(accelerometer_x)
                    out_x = remove_outliers(out_pd)

                    # 計算濾波器係數
                    '''
                    nyquist_freq = 0.5 * fs
                    low = lowcut / nyquist_freq
                    high = highcut / nyquist_freq
                    b, a = butter(order, [low, high], btype="bandstop")
                    df_x = filtfilt(b, a, out_x)
                    '''
                    # 設計低通濾波器
                    cutoff = highcut  # 截止頻率
                    nyq = 0.5 * fs  # Nyquist頻率
                    normal_cutoff = cutoff / nyq
                    b, a = butter(4, normal_cutoff, btype='low', analog=False)

                    # 使用濾波器濾波信號
                    filtered_x = filtfilt(b, a, accelerometer_x)

                    # 設置參數
                    N = sampleRate_rate      # 訊號長度
                    T = 1 / sampleRate_rate   # 取樣週期
                    y_f = np.fft.fft(filtered_x)
                    x_f = np.linspace(0.0, 1.0/(2.0*T), N//2)

                
                    self.ui.MplWidget.canvas.figure.clf()
                    self.ui.MplWidget.canvas.axes0 = self.ui.MplWidget.canvas.figure.add_subplot(411)
                    self.ui.MplWidget.canvas.axes1 = self.ui.MplWidget.canvas.figure.add_subplot(412)
                    self.ui.MplWidget.canvas.axes2 = self.ui.MplWidget.canvas.figure.add_subplot(413)
                    self.ui.MplWidget.canvas.axes3 = self.ui.MplWidget.canvas.figure.add_subplot(414)

                    self.ui.MplWidget.canvas.axes0.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes0.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes0.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes0.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes0.set_ylim([self.listx_min, self.listx_max])
                    self.ui.MplWidget.canvas.axes0.plot(t_list, accelerometer_x, color='red')  
                    self.ui.MplWidget.canvas.axes0.set_title('Accelerometer (X)')

                    self.ui.MplWidget.canvas.axes1.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes1.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes1.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes1.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes1.set_ylim([self.listx_min, self.listx_max])
                    self.ui.MplWidget.canvas.axes1.plot(t_list, out_x, color='#FF8328')  
                    self.ui.MplWidget.canvas.axes1.set_title('Remove Outliers Accelerometer (X)')

                    self.ui.MplWidget.canvas.axes2.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes2.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes2.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes2.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes2.set_ylim([self.listx_min, self.listx_max])
                    self.ui.MplWidget.canvas.axes2.plot(t_list, filtered_x, color='blue')  
                    self.ui.MplWidget.canvas.axes2.set_title('Filt Accelerometer (X)') 

                    self.ui.MplWidget.canvas.axes3.set_xlabel("Frequency(Hz)")
                    self.ui.MplWidget.canvas.axes3.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes3.set_xlim([0, 200])
                    self.ui.MplWidget.canvas.axes3.set_ylim([0, 1])
                    self.ui.MplWidget.canvas.axes3.plot(x_f, 2.0/N * np.abs(y_f[:N//2]), color='green')  
                    self.ui.MplWidget.canvas.axes3.set_title('FFT Accelerometer (X)')     

                    self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                    self.ui.MplWidget.canvas.draw()

                elif self.ui.ckb_Y.isChecked() and not(self.ui.ckb_rms.isChecked()):
                    #四分位距法去除離群值
                    out_pd = pd.Index(accelerometer_y)
                    out_y = remove_outliers(out_pd)

                    '''
                    nyquist_freq = 0.5 * fs
                    low = lowcut / nyquist_freq
                    high = highcut / nyquist_freq
                    b, a = butter(order, [low, high], btype="bandstop")
                    df_x = filtfilt(b, a, out_x)
                    '''
                    # 設計低通濾波器
                    cutoff = highcut  # 截止頻率
                    nyq = 0.5 * fs  # Nyquist頻率
                    normal_cutoff = cutoff / nyq
                    b, a = butter(4, normal_cutoff, btype='low', analog=False)

                    # 使用濾波器濾波信號
                    filtered_y = filtfilt(b, a, accelerometer_y)

                    # 設置參數
                    N = sampleRate_rate      # 訊號長度
                    T = 1 / sampleRate_rate   # 取樣週期
                    y_f = np.fft.fft(filtered_y)
                    x_f = np.linspace(0.0, 1.0/(2.0*T), N//2)

                    self.ui.MplWidget.canvas.figure.clf()
                    self.ui.MplWidget.canvas.axes0 = self.ui.MplWidget.canvas.figure.add_subplot(411)
                    self.ui.MplWidget.canvas.axes1 = self.ui.MplWidget.canvas.figure.add_subplot(412)
                    self.ui.MplWidget.canvas.axes2 = self.ui.MplWidget.canvas.figure.add_subplot(413)
                    self.ui.MplWidget.canvas.axes3 = self.ui.MplWidget.canvas.figure.add_subplot(414)

                    self.ui.MplWidget.canvas.axes0.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes0.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes0.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes0.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes0.set_ylim([self.listy_min, self.listy_max])
                    self.ui.MplWidget.canvas.axes0.plot(t_list, accelerometer_y, color='red')  
                    self.ui.MplWidget.canvas.axes0.set_title('Accelerometer (Y)')

                    self.ui.MplWidget.canvas.axes1.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes1.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes1.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes1.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes1.set_ylim([self.listy_min, self.listy_max])
                    self.ui.MplWidget.canvas.axes1.plot(t_list, out_y, color='#FF8328')  
                    self.ui.MplWidget.canvas.axes1.set_title('Remove Outliers Accelerometer (Y)')

                    self.ui.MplWidget.canvas.axes2.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes2.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes2.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes2.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes2.set_ylim([self.listy_min, self.listy_max])
                    self.ui.MplWidget.canvas.axes2.plot(t_list, filtered_y, color='blue')  
                    self.ui.MplWidget.canvas.axes2.set_title('Filt Accelerometer (Y)') 

                    self.ui.MplWidget.canvas.axes3.set_xlabel("Frequency(Hz)")
                    self.ui.MplWidget.canvas.axes3.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes3.set_xlim([0, 200])
                    self.ui.MplWidget.canvas.axes3.set_ylim([0, 1])
                    self.ui.MplWidget.canvas.axes3.plot(x_f, 2.0/N * np.abs(y_f[:N//2]), color='green')  
                    self.ui.MplWidget.canvas.axes3.set_title('FFT Accelerometer (Y)')     

                    self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                    self.ui.MplWidget.canvas.draw()
                    
                elif self.ui.ckb_Z.isChecked() and not(self.ui.ckb_rms.isChecked()):
                    #四分位距法去除離群值
                    out_pd = pd.Index(accelerometer_z)
                    out_z = remove_outliers(out_pd)

                    '''
                    nyquist_freq = 0.5 * fs
                    low = lowcut / nyquist_freq
                    high = highcut / nyquist_freq
                    b, a = butter(order, [low, high], btype="bandstop")
                    df_x = filtfilt(b, a, out_x)
                    '''
                    # 設計低通濾波器
                    cutoff = highcut  # 截止頻率
                    nyq = 0.5 * fs  # Nyquist頻率
                    normal_cutoff = cutoff / nyq
                    b, a = butter(4, normal_cutoff, btype='low', analog=False)

                    # 使用濾波器濾波信號
                    filtered_z = filtfilt(b, a, accelerometer_z)

                    # 設置參數
                    N = sampleRate_rate      # 訊號長度
                    T = 1 / sampleRate_rate   # 取樣週期
                    y_f = np.fft.fft(filtered_z)
                    x_f = np.linspace(0.0, 1.0/(2.0*T), N//2)

                    self.ui.MplWidget.canvas.figure.clf()
                    self.ui.MplWidget.canvas.axes0 = self.ui.MplWidget.canvas.figure.add_subplot(411)
                    self.ui.MplWidget.canvas.axes1 = self.ui.MplWidget.canvas.figure.add_subplot(412)
                    self.ui.MplWidget.canvas.axes2 = self.ui.MplWidget.canvas.figure.add_subplot(413)
                    self.ui.MplWidget.canvas.axes3 = self.ui.MplWidget.canvas.figure.add_subplot(414)

                    self.ui.MplWidget.canvas.axes0.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes0.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes0.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes0.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes0.set_ylim([self.listz_min, self.listz_max])
                    self.ui.MplWidget.canvas.axes0.plot(t_list, accelerometer_z, color='red')  
                    self.ui.MplWidget.canvas.axes0.set_title('Accelerometer (Z)')

                    self.ui.MplWidget.canvas.axes1.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes1.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes1.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes1.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes1.set_ylim([self.listz_min, self.listz_max])
                    self.ui.MplWidget.canvas.axes1.plot(t_list, out_z, color='#FF8328')  
                    self.ui.MplWidget.canvas.axes1.set_title('Remove Outliers Accelerometer (Z)')

                    self.ui.MplWidget.canvas.axes2.set_xlabel("Time(sec)")
                    self.ui.MplWidget.canvas.axes2.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes2.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                    #self.MplWidget.canvas.axes2.set_xlim([origin, t])
                    self.ui.MplWidget.canvas.axes2.set_ylim([self.listz_min, self.listz_max])
                    self.ui.MplWidget.canvas.axes2.plot(t_list, filtered_z, color='blue')  
                    self.ui.MplWidget.canvas.axes2.set_title('Filt Accelerometer (Z)') 

                    self.ui.MplWidget.canvas.axes3.set_xlabel("Frequency(Hz)")
                    self.ui.MplWidget.canvas.axes3.set_ylabel("g(m/s\u00B2)")
                    self.ui.MplWidget.canvas.axes3.set_xlim([0, 200])
                    self.ui.MplWidget.canvas.axes3.set_ylim([0, 1])
                    self.ui.MplWidget.canvas.axes3.plot(x_f, 2.0/N * np.abs(y_f[:N//2]), color='green')  
                    self.ui.MplWidget.canvas.axes3.set_title('FFT Accelerometer (Z)')     

                    self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                    self.ui.MplWidget.canvas.draw()

                elif self.ui.ckb_rms.isChecked():
                    # self.current_mode()                                       
                    if self.ui.ckb_X.isChecked():
                        # 關閉其他軸，避免衝突
                        self.ui.ckb_Y.setChecked(False)
                        self.ui.ckb_Z.setChecked(False)

                        self.ui.MplWidget.canvas.figure.clf()
                        #-----------------------------RMS-----------------------------#
                        self.ui.MplWidget.canvas.axes0 = self.ui.MplWidget.canvas.figure.add_subplot(211)
                        self.ui.MplWidget.canvas.axes0_rms = self.ui.MplWidget.canvas.figure.add_subplot(212)

                        self.ui.MplWidget.canvas.axes0.set_xlabel("Time(sec)")
                        self.ui.MplWidget.canvas.axes0.set_ylabel("g(m/s\u00B2)")
                        self.ui.MplWidget.canvas.axes0.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                        #self.MplWidget.canvas.axes0.set_xlim([origin, t])
                        # self.ui.MplWidget.canvas.axes0.set_ylim([-2, 2])
                        self.ui.MplWidget.canvas.axes0.set_ylim([self.listx_min, self.listx_max])
                        self.ui.MplWidget.canvas.axes0.plot(t_list, accelerometer_x, color='red')

                        if len(t_rms_list) > 0:
                            self.ui.MplWidget.canvas.axes0_rms.set_xlabel("Time(sec)")
                            self.ui.MplWidget.canvas.axes0_rms.set_ylabel("g(m/s\u00B2)")
                            self.ui.MplWidget.canvas.axes0_rms.set_xlim([t_rms_list[0], t_rms_list[-1]])
                            #self.MplWidget.canvas.axes0_rms.set_xlim([origin, t])
                            # self.ui.MplWidget.canvas.axes0_rms.set_ylim([0, 5])
                            self.ui.MplWidget.canvas.axes0.set_ylim([self.listx_min, self.listx_max])
                            self.ui.MplWidget.canvas.axes0_rms.plot(t_rms_list, accelerometer_xrms, color='red')

                        self.ui.MplWidget.canvas.axes0.set_title('Accelerometer (X)')
                        self.ui.MplWidget.canvas.axes0_rms.set_title('Accelerometer_rms (X)')

                        self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                        self.ui.MplWidget.canvas.draw()

                    elif self.ui.ckb_Y.isChecked():
                        self.ui.ckb_X.setChecked(False)
                        self.ui.ckb_Z.setChecked(False)

                        self.ui.MplWidget.canvas.figure.clf()
                        self.ui.MplWidget.canvas.axes1 = self.ui.MplWidget.canvas.figure.add_subplot(211)
                        self.ui.MplWidget.canvas.axes1_rms = self.ui.MplWidget.canvas.figure.add_subplot(212)

                        self.ui.MplWidget.canvas.axes1.set_xlabel("Time(sec)")
                        self.ui.MplWidget.canvas.axes1.set_ylabel("g(m/s\u00B2)")
                        self.ui.MplWidget.canvas.axes1.set_xlim([origin/sampleRate_rate, t/sampleRate_rate])
                        #sel.uif.MplWidget.canvas.axes1.set_xlim([origin, t])
                        # self.ui.MplWidget.canvas.axes1.set_ylim([-1.5, 1.5])
                        self.ui.MplWidget.canvas.axes1.set_ylim([self.listy_min, self.listy_max])
                        self.ui.MplWidget.canvas.axes1.plot(t_list, accelerometer_y, color='green')

                        if len(t_rms_list) > 0:
                            self.ui.MplWidget.canvas.axes1_rms.set_xlabel("Time(sec)")
                            self.ui.MplWidget.canvas.axes1_rms.set_ylabel("g(m/s\u00B2)")
                            self.ui.MplWidget.canvas.axes1_rms.set_xlim([t_rms_list[0], t_rms_list[-1]])
                            #self.MplWidget.canvas.axes0_rms.set_xlim([origin, t])
                            # self.ui.MplWidget.canvas.axes1_rms.set_ylim([0, 10])
                            self.ui.MplWidget.canvas.axes1.set_ylim([self.listy_min, self.listy_max])
                            self.ui.MplWidget.canvas.axes1_rms.plot(t_rms_list, accelerometer_yrms, color='green')

                        self.ui.MplWidget.canvas.axes1.set_title('Accelerometer (Y)')
                        self.ui.MplWidget.canvas.axes1_rms.set_title('Accelerometer_rms (Y)')

                        self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                        self.ui.MplWidget.canvas.draw()
                    
                    elif self.ui.ckb_Z.isChecked():
                        self.ui.ckb_X.setChecked(False)
                        self.ui.ckb_Y.setChecked(False)
                        

                        self.ui.MplWidget.canvas.figure.clf()
                        self.ui.MplWidget.canvas.axes2 = self.ui.MplWidget.canvas.figure.add_subplot(211)
                        self.ui.MplWidget.canvas.axes2_rms = self.ui.MplWidget.canvas.figure.add_subplot(212)

                        self.ui.MplWidget.canvas.axes2.set_xlabel("Time(sec)")
                        self.ui.MplWidget.canvas.axes2.set_ylabel("g(m/s\u00B2)")
                        self.ui.MplWidget.canvas.axes2.set_xlim([t_list[0], t_list[-1]])
                        #self.MplWidget.canvas.axes0_rms.set_xlim([origin, t])
                        # self.ui.MplWidget.canvas.axes2.set_ylim([-1.5, 1.5])
                        self.ui.MplWidget.canvas.axes2.set_ylim([self.listz_min, self.listz_max])
                        self.ui.MplWidget.canvas.axes2.plot(t_list, accelerometer_z, color='blue')

                        if len(t_rms_list) > 0:
                            self.ui.MplWidget.canvas.axes2_rms.set_xlabel("Time(sec)")
                            self.ui.MplWidget.canvas.axes2_rms.set_ylabel("g(m/s\u00B2)")
                            self.ui.MplWidget.canvas.axes2_rms.set_xlim([t_rms_list[0], t_rms_list[-1]])
                            #self.MplWidget.canvas.axes0_rms.set_xlim([origin, t])
                            # self.ui.MplWidget.canvas.axes2_rms.set_ylim([0, 16])
                            self.ui.MplWidget.canvas.axes2.set_ylim([self.listz_min, self.listz_max])
                            self.ui.MplWidget.canvas.axes2_rms.plot(t_rms_list, accelerometer_zrms, color='blue')

                        self.ui.MplWidget.canvas.axes2.set_title('Accelerometer (Z)')
                        self.ui.MplWidget.canvas.axes2_rms.set_title('Accelerometer_rms (Z)')

                        self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                        self.ui.MplWidget.canvas.draw()

                    else:
                        self.ui.ckb_X.setChecked(False)
                        self.ui.ckb_Y.setChecked(False)
                        self.ui.ckb_Z.setChecked(False)
                
                        self.ui.MplWidget.canvas.figure.clf()
                        self.ui.MplWidget.canvas.axes0_rms = self.ui.MplWidget.canvas.figure.add_subplot(311)
                        self.ui.MplWidget.canvas.axes1_rms = self.ui.MplWidget.canvas.figure.add_subplot(312)
                        self.ui.MplWidget.canvas.axes2_rms = self.ui.MplWidget.canvas.figure.add_subplot(313)

                        self.ui.MplWidget.canvas.axes0_rms.set_ylim([self.listx_min, self.listx_max])                         
                        self.ui.MplWidget.canvas.axes1_rms.set_ylim([self.listy_min, self.listy_max])
                        self.ui.MplWidget.canvas.axes2_rms.set_ylim([self.listz_min, self.listz_max])
                       

                        #-----------------------------RMS-----------------------------#
                        if len(t_rms_list) > 0:
                            self.ui.MplWidget.canvas.axes0_rms.set_xlabel("Time(sec)")
                            self.ui.MplWidget.canvas.axes0_rms.set_ylabel("g(m/s\u00B2)")
                            self.ui.MplWidget.canvas.axes0_rms.set_xlim([t_rms_list[0], t_rms_list[-1]])
                            #self.MplWidget.canvas.axes0_rms.set_xlim([origin, t])
                            # self.ui.MplWidget.canvas.axes0_rms.set_ylim([0, 5])
                            self.ui.MplWidget.canvas.axes0_rms.set_ylim([self.listx_min, self.listx_max])
                            self.ui.MplWidget.canvas.axes0_rms.plot(t_rms_list, accelerometer_xrms, color='red')
                            
                            self.ui.MplWidget.canvas.axes1_rms.set_xlabel("Time(sec)")
                            self.ui.MplWidget.canvas.axes1_rms.set_ylabel("g(m/s\u00B2)")
                            self.ui.MplWidget.canvas.axes1_rms.set_xlim([t_rms_list[0], t_rms_list[-1]])
                            #self.MplWidget.canvas.axes0_rms.set_xlim([origin, t])
                            # self.ui.MplWidget.canvas.axes1_rms.set_ylim([0, 10])
                            self.ui.MplWidget.canvas.axes1_rms.set_ylim([self.listy_min, self.listz_max])
                            self.ui.MplWidget.canvas.axes1_rms.plot(t_rms_list, accelerometer_yrms, color='green')

                            self.ui.MplWidget.canvas.axes2_rms.set_xlabel("Time(sec)")
                            self.ui.MplWidget.canvas.axes2_rms.set_ylabel("g(m/s\u00B2)")
                            self.ui.MplWidget.canvas.axes2_rms.set_xlim([t_rms_list[0], t_rms_list[-1]])
                            #self.MplWidget.canvas.axes0_rms.set_xlim([origin, t])
                            # self.ui.MplWidget.canvas.axes2_rms.set_ylim([0, 16])
                            self.ui.MplWidget.canvas.axes2_rms.set_ylim([self.listz_min, self.listz_max])
                            self.ui.MplWidget.canvas.axes2_rms.plot(t_rms_list, accelerometer_zrms, color='blue')

                        #-----------------------------RMS-----------------------------#
                        self.ui.MplWidget.canvas.axes0_rms.set_title('Accelerometer_rms (X)')
                        self.ui.MplWidget.canvas.axes1_rms.set_title('Accelerometer_rms (Y)')
                        self.ui.MplWidget.canvas.axes2_rms.set_title('Accelerometer_rms (Z)')

                        self.ui.MplWidget.canvas.figure.tight_layout() #隔開兩個圖
                        self.ui.MplWidget.canvas.draw()

                else:
                    self.ui.MplWidget.canvas.figure.clf()
                    self.ui.MplWidget.canvas.draw()

        def click_acc(self):
            self.listx_max = float(self.acc_Xmax)
            self.listy_max = float(self.acc_Ymax)
            self.listz_max = float(self.acc_Zmax)
            self.listx_min = float(self.acc_Xmin)
            self.listy_min = float(self.acc_Ymin)
            self.listz_min = float(self.acc_Zmin)

            if self.ui.ckb_acc.isChecked():
                           
                self.ui.ckb_rms.setChecked(False)
                self.ui.ckb_acc_out.setChecked(False)
                
                self.mode = 'acc'

                self.ui.ckb_X.setChecked(True)
                self.ui.ckb_Y.setChecked(True)
                self.ui.ckb_Z.setChecked(True)

                #將輸入框設成預設值
                self.ui.lineEdit_Xmax.setText(self.acc_Xmax)
                self.ui.lineEdit_Xmin.setText(self.acc_Xmin)
                self.ui.lineEdit_Ymax.setText(self.acc_Ymax)
                self.ui.lineEdit_Ymin.setText(self.acc_Ymin)
                self.ui.lineEdit_Zmax.setText(self.acc_Zmax)
                self.ui.lineEdit_Zmin.setText(self.acc_Zmin)
            else:

                self.ui.ckb_X.setChecked(False)
                self.ui.ckb_Y.setChecked(False)
                self.ui.ckb_Z.setChecked(False)
         
        def click_acc_out(self):
            global LC
            global HC
            if self.ui.ckb_acc_out.isChecked():
         
                self.ui.ckb_acc.setChecked(False)
                self.ui.ckb_rms.setChecked(False)

                self.ui.ckb_X.setChecked(True)
                self.ui.ckb_Y.setChecked(True)
                self.ui.ckb_Z.setChecked(True)
                LC = int(self.ui.lineEdit_lowcut.text())
                HC = int(self.ui.lineEdit_highcut.text())
            else:
       
                self.ui.ckb_X.setChecked(False)
                self.ui.ckb_Y.setChecked(False)
                self.ui.ckb_Z.setChecked(False)

        def click_rms(self):
            self.listx_max = float(self.rms_Xmax) 
            self.listy_max = float(self.rms_Ymax)
            self.listz_max = float(self.rms_Zmax)
            self.listx_min = float(self.rms_Xmin)
            self.listy_min = float(self.rms_Ymin)
            self.listz_min = float(self.rms_Zmin)

            if self.ui.ckb_rms.isChecked():
                self.mode = 'rms'
                self.ui.ckb_acc.setChecked(False)
                self.ui.ckb_acc_out.setChecked(False)
                # self.ui.ckb_X.setChecked(True)
                # self.ui.ckb_Y.setChecked(True)
                # self.ui.ckb_Z.setChecked(True)
                
                #將輸入框設成預設值
                self.ui.lineEdit_Xmax.setText(self.rms_Xmax)
                self.ui.lineEdit_Xmin.setText(self.rms_Xmin)
                self.ui.lineEdit_Ymax.setText(self.rms_Ymax)
                self.ui.lineEdit_Ymin.setText(self.rms_Ymin)
                self.ui.lineEdit_Zmax.setText(self.rms_Zmax)
                self.ui.lineEdit_Zmin.setText(self.rms_Zmin)

            else:
                self.ui.ckb_X.setChecked(False)
                self.ui.ckb_Y.setChecked(False)
                self.ui.ckb_Z.setChecked(False)

        def current_mode(self):
            if self.mode == 'acc':
                try:
                    float(self.ui.lineEdit_Xmax.text())
                    float(self.ui.lineEdit_Ymax.text())
                    float(self.ui.lineEdit_Zmax.text())

                    float(self.ui.lineEdit_Xmin.text())
                    float(self.ui.lineEdit_Ymin.text())
                    float(self.ui.lineEdit_Zmin.text())

                    self.acc_Xmax = self.ui.lineEdit_Xmax.text()
                    self.acc_Ymax = self.ui.lineEdit_Ymax.text()
                    self.acc_Zmax = self.ui.lineEdit_Zmax.text()

                    self.acc_Xmin = self.ui.lineEdit_Xmin.text()
                    self.acc_Ymin = self.ui.lineEdit_Ymin.text()
                    self.acc_Zmin = self.ui.lineEdit_Zmin.text()

                except:
                    print("輸入格式錯誤")
            elif self.mode == 'rms':
                try:
                    float(self.ui.lineEdit_Xmax.text())
                    float(self.ui.lineEdit_Ymax.text())
                    float(self.ui.lineEdit_Zmax.text())

                    float(self.ui.lineEdit_Xmin.text())
                    float(self.ui.lineEdit_Ymin.text())
                    float(self.ui.lineEdit_Zmin.text())

                    self.rms_Xmax = self.ui.lineEdit_Xmax.text()
                    self.rms_Ymax = self.ui.lineEdit_Ymax.text()
                    self.rms_Zmax = self.ui.lineEdit_Zmax.text()

                    self.rms_Xmin = self.ui.lineEdit_Xmin.text()
                    self.rms_Ymin = self.ui.lineEdit_Ymin.text()
                    self.rms_Zmin = self.ui.lineEdit_Zmin.text()

                    # self.listx_max = self.rms_Xmax 
                    # self.listy_max = self.rms_Ymax
                    # self.listz_max = self.rms_Zmax
                    # self.listx_min = self.rms_Xmin
                    # self.listy_min = self.rms_Ymin
                    # self.listz_min = self.rms_Zmin

                except:
                    print("輸入格式錯誤")
            
        def click_confirm_btn(self):
            self.current_mode() 
            if self.mode == 'acc':
                self.listx_max = float(self.acc_Xmax)
                self.listy_max = float(self.acc_Ymax)
                self.listz_max = float(self.acc_Zmax)
                self.listx_min = float(self.acc_Xmin)
                self.listy_min = float(self.acc_Ymin)
                self.listz_min = float(self.acc_Zmin)
            elif self.mode == 'rms':
                self.listx_max = float(self.rms_Xmax)
                self.listy_max = float(self.rms_Ymax)
                self.listz_max = float(self.rms_Zmax)
                self.listx_min = float(self.rms_Xmin)
                self.listy_min = float(self.rms_Ymin)
                self.listz_min = float(self.rms_Zmin)
        
        def click_X(self):
            global LC
            global HC
            if not(self.ui.ckb_rms.isChecked()) :
            
                self.ui.ckb_acc.setChecked(False)
                LC = int(self.ui.lineEdit_lowcut.text())
                HC = int(self.ui.lineEdit_highcut.text())
            else:
                self.ui.ckb_Y.setChecked(False)
                self.ui.ckb_Z.setChecked(False)

        def click_Y(self):
            global LC
            global HC
            if not(self.ui.ckb_rms.isChecked()) :
         
                self.ui.ckb_acc.setChecked(False)
                LC = int(self.ui.lineEdit_lowcut.text())
                HC = int(self.ui.lineEdit_highcut.text())
            else:
                self.ui.ckb_X.setChecked(False)
                self.ui.ckb_Z.setChecked(False)

        def click_Z(self):
            global LC
            global HC
            if not(self.ui.ckb_rms.isChecked()) :
       
                self.ui.ckb_acc.setChecked(False)
                LC = int(self.ui.lineEdit_lowcut.text())
                HC = int(self.ui.lineEdit_highcut.text())
            else:
                self.ui.ckb_X.setChecked(False)
                self.ui.ckb_Y.setChecked(False)
        

        def change_accMode(self):
            self.acc_mode = int(self.ui.ComboBox_accMode.currentText().replace('G','') )
                  
                
            


        def btn_lock(self):
            global lock
            global time_reset
            if lock == 0:
                lock = 1
                print(lock)
                self.ui.btn_stop.setText('恢復')

            elif lock == 1:
                lock = 0
                print(lock) 
                self.ui.btn_stop.setText('暫停')
        
        def click_record(self):
            global excel_state
            global ex_row
            global ex_row_rms
            global wb
            global wb_rms
            global ws
            global ws_rms
            global date_time
            self.ui.btn_record.setEnabled(False)
            self.ui.btn_save.setEnabled(True)
            excel_state = True
            ex_row = 1
            ex_row_rms = 1

            date_time = time.strftime("%Y-%m-%d_%H_%M_%S", time.localtime())
            wb = Workbook()
            ws = wb.active
            ws.title = "data"

            '''
            ws.cell(row=ex_row, column=1, value="accelerometer_x")
            ws.cell(row=ex_row, column=2, value="accelerometer_y")
            ws.cell(row=ex_row, column=3, value="accelerometer_z")
            ex_row += 1
            '''
            # wb.save('%s.xlsx' % date_time)
            wb.save('%s.txt' % date_time)

        #------------------------RMS------------------------#
            wb_rms = Workbook()
            ws_rms = wb_rms.active
            ws_rms.title = "data_rms"
            # wb_rms.save(f"{date_time}_rms.xlsx")
            # wb_rms.save('%s_rms.xlsx' % date_time)
            wb_rms.save('%s_rms.txt' % date_time)

        def save_excel(self):
            global ws
            global ws_rms
            global wb
            global wb_rms
            global date_time
            global ex_row
            global ex_row_rms
            global accelerometer_excel
            global accelerometer_rms_excel
            global excel_state

            excel_state = False
            self.ui.btn_record.setEnabled(True)
            self.ui.btn_save.setEnabled(False)

            QMessageBox.information(None, '開始存取', '存取中請稍等')

            while len(accelerometer_excel)>0:
                #print(accelerometer_rms_excel)
                ws.cell(row=ex_row, column=1, value = round(float(accelerometer_excel[0][0]),4))
                ws.cell(row=ex_row, column=2, value = round(float(accelerometer_excel[0][1]),4))
                ws.cell(row=ex_row, column=3, value = round(float(accelerometer_excel[0][2]),4))
                ex_row += 1
                accelerometer_excel.pop(0)

            wb.save('%s.xlsx' % date_time)
            while len(accelerometer_rms_excel)>0:
                ws_rms.cell(row=ex_row_rms, column=1, value = round(float(accelerometer_rms_excel[0][0]),4))
                ws_rms.cell(row=ex_row_rms, column=2, value = round(float(accelerometer_rms_excel[0][1]),4))
                ws_rms.cell(row=ex_row_rms, column=3, value = round(float(accelerometer_rms_excel[0][2]),4))
                ws_rms.cell(row=ex_row_rms, column=4, value = accelerometer_rms_excel[0][3])
                ex_row_rms += 1
                accelerometer_rms_excel.pop(0)
            
            # wb_rms.save(f"{date_time}_rms.xlsx")
            wb_rms.save('%s_rms.xlsx' % date_time)          

            QMessageBox.information(None, '存取成功', '存取完畢請確認')

        def save_txt(self):
            global ws
            global ws_rms
            global wb
            global wb_rms
            global date_time
            global ex_row
            global ex_row_rms
            global accelerometer_excel
            global accelerometer_rms_excel
            global excel_state

            excel_state = False
            self.ui.btn_record.setEnabled(True)
            self.ui.btn_save.setEnabled(False)

            QMessageBox.information(None, '開始存取', '存取中請稍等')

            while len(accelerometer_excel)>0:
                #print(accelerometer_rms_excel)
                ws.cell(row=ex_row, column=1, value = round(float(accelerometer_excel[0][0]),4))
                ws.cell(row=ex_row, column=2, value = round(float(accelerometer_excel[0][1]),4))
                ws.cell(row=ex_row, column=3, value = round(float(accelerometer_excel[0][2]),4))
                ex_row += 1
                accelerometer_excel.pop(0)

            # wb.save('%s.xlsx' % date_time)
            wb.save('%s.txt' % date_time)

            while len(accelerometer_rms_excel)>0:
                ws_rms.cell(row=ex_row_rms, column=1, value = round(float(accelerometer_rms_excel[0][0]),4))
                ws_rms.cell(row=ex_row_rms, column=2, value = round(float(accelerometer_rms_excel[0][1]),4))
                ws_rms.cell(row=ex_row_rms, column=3, value = round(float(accelerometer_rms_excel[0][2]),4))
                ws_rms.cell(row=ex_row_rms, column=4, value = accelerometer_rms_excel[0][3])
                ex_row_rms += 1
                accelerometer_rms_excel.pop(0)
            
            wb_rms.save('%s_rms.txt' % date_time)

            QMessageBox.information(None, '存取成功', '存取完畢請確認')

        def click_record_txt(self):
            global excel_state
            global date_time
            self.ui.btn_record.setEnabled(False)
            self.ui.btn_save.setEnabled(True)
            excel_state = True

            date_time = time.strftime("%Y-%m-%d_%H_%M_%S", time.localtime())

            self.acc_file = open(f"{date_time}.txt",'w+')
            self.rms_file = open(f"{date_time}_rms.txt",'w+')

        

        # def click_save_txt(self):
 
        #     global accelerometer_excel
        #     global accelerometer_rms_excel
        #     global excel_state

        #     excel_state = False
        #     self.ui.btn_record.setEnabled(True)
        #     self.ui.btn_save.setEnabled(False)
        #     self.progress_bar.show()

        #     # QMessageBox.information(None, '開始存取', '存取中請稍等')
        #     initial_value = 0
            
        #     self.bar1.setRange(0, len(accelerometer_excel))
        #     while len(accelerometer_excel)>0:
        #         #print(accelerometer_rms_excel)                
        #         self.acc_file.write(f"{round(float(accelerometer_excel[0][0]),4)},{round(float(accelerometer_excel[0][1]),4)},{round(float(accelerometer_excel[0][2]),4)}\n")
        #         accelerometer_excel.pop(0)
        #         initial_value += 1
        #         self.bar1.setValue(initial_value)
        #     self.progress_bar.close()
        #     self.acc_file.close()



        #     while len(accelerometer_rms_excel)>0:
        #         self.rms_file.write(f"{round(float(accelerometer_rms_excel[0][0]),4)},{round(float(accelerometer_rms_excel[0][1]),4)},{round(float(accelerometer_rms_excel[0][2]),4)},{accelerometer_rms_excel[0][3]}\n")
        #         accelerometer_rms_excel.pop(0)
        #     self.rms_file.close()
            # QMessageBox.information(None, '存取成功', '存取完畢請確認')
        
        def click_save_txt_thread(self):
            global accelerometer_excel
            global accelerometer_rms_excel
            global excel_state
            excel_state = False
            self.ui.btn_record.setEnabled(True)
            self.ui.btn_save.setEnabled(False)

            


            # with open('71-75.txt','r') as f:
            #     for i in f.readlines():
            #         a = i.split(',')
            #         accelerometer_excel.append([float(a[0]),float(a[1]),float(a[2])])

            # with open('rms.txt','r') as f:
            #     for i in f.readlines():
            #         a = i.split(',')
            #         accelerometer_rms_excel.append([float(a[0]),float(a[1]),float(a[2])])

            # accelerometer_excel.append([1,2,3])
            # accelerometer_rms_excel.append([0,1,2,3])
            
            self.progress_bar.show()
            if len(accelerometer_excel) > 0:
                self.save = SaveThread(accelerometer_excel, accelerometer_rms_excel, self.acc_file, self.rms_file)
                self.save.set_trigger.connect(self.set_bar)
                self.save.data_trigger.connect(self.run_bar)
                self.save.close_trigger.connect(self.progress_bar.close)
                self.save.start()
            else:self.progress_bar.close()

        def set_bar(self,max_value):
            self.bar1.setValue(0)    
            self.bar1.setRange(0, max_value)
        def run_bar(self,data):
            self.bar1.setValue(data[0])
        def frequency_count(self,frequency):
            self.frequency_list.append(frequency)
            # self.ui.label_frequency.setText(f"取樣率 : {int(sum(self.frequency_list)/len(self.frequency_list))}")
            if len(self.frequency_list) >= 10:
                self.frequency_list = []
        def batt_update(self,batt):
            batt_list = batt.split(",")
            self.ui.value_power.setText(f"{batt_list[0]}%")
            self.ui.value_voltage.setText(f"{batt_list[1]}mV")
            self.ui.value_current.setText(f"{batt_list[2]}mA")
def remove_outliers(data, threshold1=0.07, threshold2=0.14):
    """
    去除異常值的函式
    :param data: 要處理的資料，為一維 numpy array
    :param threshold: 設定的異常值閥值，預設為 0.1
    :return: 處理後的資料，為一維 numpy array
    """
    result = data.copy()
    for i in range(1, len(data)):
        #diff1 = (abs(data[i]) - abs(data[i-1])) / abs(data[i-1])
        #diff2 = (abs(data[i-1]) - abs(data[i])) / abs(data[i])
        #diff1 = abs(abs(data[i]) - abs(data[i-1]))
        #diff2 = abs(abs(data[i-1]) - abs(data[i]))
        diff = abs(data[i] - data[i-1])
        if (diff >= threshold1) and (diff <= threshold2):
            start = max(0, i-1)
            end = min(len(data), i+2)
            avg = np.mean(data[start:end])
            ret = list(result)
            ret[i] = avg
            result = ret
    return result

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    controller = MainWindow_controller()
    controller.show()
    sys.exit(app.exec_())
   
        
